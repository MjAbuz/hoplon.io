(ns io.hoplon.content.docs
  (:require-macros
    [bootstrap.code           :as code])
  (:require
    [io.hoplon                :as hoplon]
    [bootstrap.grid           :as grid]
    [bootstrap.panel          :as panel]
    [io.hoplon.content.shared :refer [copyright-footer boot-url]]))

(defn show [hdoc hdocs]
  (grid/row
    (grid/col4
      (panel/default
        :class "affix hidden-xs hidden-sm"
        (panel/heading
          (panel/title "Table of Contents"))
        (panel/body
          (grid/row
            (grid/col12
              (hoplon/table-of-contents :size 10 :toc hdocs))))))
    (grid/col8
      (hoplon/jump-to-toc :tocs (cell= [hdocs]))
      (h1
        "Docs" (br)
        (small "Basic Hoplon docs."))
      (hr)
      (panel/default
        :class "hidden-md hidden-lg"
        (panel/heading
          (panel/title "Table of Contents"))
        (panel/body
          (grid/row
            (grid/col12
              (hoplon/table-of-contents :size 10 :toc hdocs)))))
      (hdoc :title "Creating a Hoplon project"
        (p
          "To create a new Hoplon project you can use " (code "lein") ":")
        (code/highlight :bash
          ;;{{
          $ lein new hoplon my-project
          ;;}}
          ))
      (hdoc :title "Boot"
        (p "Boot is a build tool used for Hoplon projects. It's also other
          things, but here we are interested in using it with a Hoplon
          project. There is more documentation at the "
          (a :href boot-url "Boot project page") ", but the information
          below is enough for most Hoplon related purposes."))
      (hdoc :title "Boot: Options"
        (p
          "Hoplon source files are compiled by the Hoplon compiler. The
          easiest way to do this is to use the " (code "hoplon") " boot
          task. Options to boot tasks can be specified by wrapping the
          task name and arguments in a vector. (Boot reads in the command
          line arguments as an EDN string.) The " (code "hoplon") " task
          takes a single command line argument – a map of key/value options.")
        (p
          "The options map may include options to be passed to the
          ClojureScript compiler (" (code ":optimizations") ", "
          (code ":source-map") ", etc.). Setting the " (code ":prerender")
          " key to false will disable the “prerendering” of
          DOM content in " (tt "phantomjs(1)") ", which speeds up the
          compilation process at the expense of SEO (handy when developing
          but probably not ideal for production builds).")

        (p
          "A typical development build invocation could look something like
          this:")
        (code/highlight :bash
          ;;{{
          $ boot watch [hoplon {:prerender false :pretty-print true}]
          ;;}}
          )
        (p "Production builds could look something like this:")
        (code/highlight :bash
          ;;{{
          $ boot [hoplon {:optimizations :advanced}]
          ;;}}
          )

        (p
          "Command line arguments can be specified in the project "
          (code "build.boot") " file as their own tasks using "
          (code "deftask") ". The above examples are already in the
          generated " (code "build.boot") ", as " (code "development") " and "
          (code "production") ". We will see them later with more detail.")

        (code/markdown
          ;;{{
          Here are some useful boot commands:
          ;;}}
          )
        (code/highlight :bash
          ;;{{
          # display list of available tasks
          $ boot help

          # build for development
          $ boot development

          # build for production
          $ boot production
          ;;}}
          )
        (p
          "Options can be passed to the JVM by setting the " (code "JVM_OPTS")
          " environment variable. For example, JVM heap space can be set to
          1G like this:")
        (code/highlight :bash
          ;;{{
          $ JVM_OPTS="-Xmx1g" boot watch hoplon
          ;;}}
          )
        )
      (hdoc :title "Boot: Configuration"
        (p
          "If you just want to take Hoplon for a quick ride you may skip
          this section. Just run " (code "boot develpment") " in a terminal and
          go edit " (code "src/index.cljs.hl") ". Boot will recompile
          when you save the file. Open " (code "resources/public/index.html")
          " on your browser to see the result.")

        (p
          "Here is the " (code "build.boot") " file generated with the new
          project:")
        (code/highlight :clj
          ;;{{
          #!/usr/bin/env boot

          #tailrecursion.boot.core/version "2.3.1"

          (set-env!
            :project      'my-project
            :version      "0.1.0-SNAPSHOT"
            :dependencies '[[tailrecursion/boot.task   "2.1.3"]
                            [tailrecursion/hoplon      "5.8.3"]
                            [org.clojure/clojurescript "0.0-2202"]]
            :out-path     "resources/public"
            :src-paths    #{"src"})

          ;; Static resources (css, images, etc.):
          (add-sync! (get-env :out-path) #{"assets"})

          (require '[tailrecursion.hoplon.boot :refer :all])

          (deftask development
            "Build my-project for development."
            []
            (comp (watch) (hoplon {:prerender false :pretty-print true})))

          (deftask production
            "Build my-project for production."
            []
            (hoplon {:optimizations :advanced}))
          ;;}}
          )

        (p
          "Let's take a look in each part of this file.")
        (p
          "This line is the shebang. It just tells the shell to use boot to
          interpret the file.")
        (code/highlight :clj
          ;;{{
          #!/usr/bin/env boot
          ;;}}
          )
        (p
          "Here we have the version of " (code "boot.core") " used in the file.
          If you ever need to change this version, this is where you do it.")
        (code/highlight :clj
          ;;{{
          #tailrecursion.boot.core/version "2.3.1"
          ;;}}
          )
        (p
          "Now we use " (code "set-env!") " to configure the project. We have
          the project name, version, dependencies. They work as you would
          expect if you have some experience with " (code "lein") ".")
        (code/highlight :clj
          ;;{{
          (set-env!
            :project      'my-project
            :version      "0.1.0-SNAPSHOT"
            :dependencies '[[tailrecursion/boot.task   "2.1.3"]
                            [tailrecursion/hoplon      "5.8.3"]
                            [org.clojure/clojurescript "0.0-2202"]]
            :out-path     "resources/public"
            :src-paths    #{"src"})
          ;;}}
          )
        (p
          "The other keys in " (code "set-env!") " are important when building
          Hoplon applications. Understanding how these keys work will help you
          to organize your Hoplon project in a way that works best for your
          workflow and deployment situation.")
        (dl :class "dl-horizontal"
          (dt (tt ":out-path"))
          (dd
            (p
              "The output directory for the Hoplon compiler. HTML and
              static content ends up here. This is where you point your
              webserver's document root."))
          (dt (tt ":src-paths"))
          (dd
            (p
              "A set of paths in which the build process looks for source
              files to compile. These directories can contain Hoplon,
              Clojure, ClojureScript, JavaScript, or any other type of
              source file. The various compilers generally dispatch on
              filename extension, so the directory structure is pretty
              much up to you. The file watcher monitors these directories
              for changes and recompiles the project when necessary.")))
        (p
          "You can use " (code "add-sync!") " to instruct boot to copy files
          when it compiles your project. This line tells boot to copy what
          is inside " (code "assets") " and put in the " (code ":out-path")
          ", that is pointing to " (code "resources/public") ". This way you
          can put static assets in the " (code "assets") " folder and they
          will be available on " (code "resources/public") ".")
        (code/highlight :clj
          ;;{{
          (add-sync! (get-env :out-path) #{"assets"})
          ;;}}
          )
        (p
          (code "add-sync!") " will respect the folder structure when copying
          the files. And if you want, you could keep your css, js and images
          files in separared folders and use " (code "add-sync!") " on each
          one to copy them to the output folder.")

        (p
          "Your new Hoplon project includes a "(code ".gitignore") " file.
          The boot watch task uses your " (tt "git(1)")  " configuration to
          determine which files will trigger recompiling and which will be
          ignored.")

        (p
          (code "require") " works like in clojure. Here we are making
          the code on the " (code "tailrecursion.hoplon.boot") " namespace
          available.")
        (code/highlight :clj
          ;;{{
          (require '[tailrecursion.hoplon.boot :refer :all])
          ;;}}
          )

        (p
          "Now we have the boot tasks. The first one is the "
          (code "development") " task. It is a composition of two other,
          tasks from the namespace required above: " (code "watch") " and "
          (code "hoplon") ". We also give some options to the hoplon task.")
        (code/highlight :clj
          ;;{{
          (deftask development
            "Build my-project for development."
            []
            (comp (watch) (hoplon {:prerender false :pretty-print true})))
          ;;}}
          )
        (p
          "The " (code "watch") " task makes boot recompile the project
          when you save your files. And the " (code "hoplon") " one tells
          boot that it is a hoplon project, so it needs to be compiled in
          a certain way.")
        (p
          "Then you can run " (code "boot development") " in a terminal.
          Boot will compile the Hoplon project and will watch for changes
          on the project files. When files change it recompiles automatically.")

        (p
          "Another example of boot task is the " (code "production") " one.
          You probably know what it does. It compiles the Hoplon project
          using advanced ClojureScript compilation. You can use it running"
          (code "boot production") " in a terminal.")
        (code/highlight :clj
          ;;{{
          (deftask production
            "Build my-project for production."
            []
            (hoplon {:optimizations :advanced}))
          ;;}}
          ))

      (hdoc :title "Hoplon: Source Files"
        (code/markdown
          ;;{{
          Hoplon compiles files having the `.hl` filename extension. These
          files may be Hoplon pages, which will be compiles to single-page
          apps, or ClojureScript namespaces.

          The first form in the file must be a page or namespace declaration.
          Page declarations specify the output HTML file path relative to
          the `:out-path` directory configured in the project `build.boot`
          file — `resources/public` by default.
          Namespace declarations are the same as in ClojureScript.

          In both cases, however, the Hoplon compiler refers vars and macros
          from the Hoplon and Javelin namespaces into the file namespace so
          that adding `:refer` clauses for things like `div`, `span`, etc.
          are not necessary. A special `:refer-hoplon` clause can be used to
          selectively exclude vars that are to be redefined in the file.
          ;;}}
          )
        (p :class "text-muted" "Example page declaration:")
        (code/highlight :clj
          ;;{{
          (page "foo/bar.html"
            (:refer-hoplon :exclude [div span])
            (:refer-clojure :exclude [int])
            (:require
              [clojure.set :as set]
              [clojure.string :as string])
            (:require-macros
              [foo.bar.baz :as baz :refer [quux]]))
          ;;}}
          )
        (p :class "text-muted" "Example namespace declaration:")
        (code/highlight :clj
          ;;{{
          (ns foo.bar
            (:refer-hoplon :exclude [div span])
            (:refer-clojure :exclude [int])
            (:require
              [clojure.set :as set]
              [clojure.string :as string])
            (:require-macros
              [foo.bar.baz :as baz :refer [quux]]))
          ;;}}
          ))

      (hdoc :title "Hoplon: Page Anatomy"
        (p
          "Hoplon page source files have three parts: the page
          declaration, optional definitions and top-level forms, and
          the page markup.")
        (h6 "ClojureScript syntax")
        (p :class "text-muted" "The page declaration:")
        (code/highlight :clj
          ;;{{
          (page "index.html"
            (:require [clojure.string :as string]))
          ;;}}
          )
        (p :class "text-muted" "Optional top-level forms and definitions:")
        (code/highlight :clj
          ;;{{
          (defn add1 [x] (+ 1 x))
          ;;}}
          )
        (p :class "text-muted" "The page markup:")
        (code/highlight :clj
          ;;{{
          (html
            (head)
            (body
              (h1 "hello, number " (str (add1 41)))))
          ;;}}
          ))

      (hdoc :title "Hoplon: ClojureScript Markup Syntax"
        (p
          "Hoplon's HTML evaluator provides a ClojureScript-based HTML syntax
          and semantic. Elements in ClojureScript markup are parenthesized
          lists, the same as Lisp expressions. The form in function position is
          the element’s HTML tag. Hoplon adds semantics for setting attributes
          and appending children. Consider a typical snippet of HTML markup:")
        (code/highlight :xml
          ;;{{
          <div id="greet" class="active">
            <h1>Hello, world!</h1>
            <p>I'm new here.</p>
          </div>
          ;;}}
          )
        (p "This snippet can be expressed in ClojureScript markup like this:")
        (code/highlight :clj
          ;;{{
          (div :id "greet" :class "active"
            (h1 "Hello, world!")
            (p "I'm new here."))
          ;;}}
          )
        (p
          "Notice how attributes can be set by passing them in first as
          alternating keyword/string pairs. The rest of the arguments are
          appended to the element (the div in this case) as children.")
        (p
          "Sometimes it’s more convenient to specify the attributes as a
          map, like this:")
        (code/highlight :clj
          ;;{{
          (div {:id "greet" :class "active"}
            (h1 "Hello, world!")
            (p "I'm new here."))
          ;;}}
          )
        (p
          "Additionally, Hoplon provides semantics for anonymous tags in
          ClojureScript markup. There is, of course, no such thing in HTML
          markup. The same snippet can be expressed using an anonymous tag:")
        (code/highlight :clj
          ;;{{
          ((div :id "greet" :class "active")
           (h1 "Hello, world!")
           (p "I'm new here."))
          ;;}}
          )
        (p
          "It’s important to understand that the " (code "div") ", "
          (code "h1") ", and " (code "p") " forms are ClojureScript
          functions that return DOM elements. DOM elements implement the "
          (code "IFn") " protocol to achieve the HTML semantic. This means
          that they can be used to form abstractions:")
        (code/highlight :clj
          ;;{{
          (defn active [& kids]
            (apply (div :class "active") kids))
          ;;}}
          )
        (p "And then, in the page markup or in a function:")
        (code/highlight :clj
          ;;{{
          (active :id "greet"
            (h1 "Hello, world!")
            (p "I'm new here."))
          ;;}}
          )
        (p "Or in HTML markup in the page, even:")
        (code/highlight :xml
          ;;{{
          <active id="greet">
            <h1>Hello, world!</h1>
            <p>I'm new here.</p>
          </active>
          ;;}}
          )
        (p
          "The result is equivalent to the previous snippets, but more
          general. These “custom tags” can be used in the page markup like
          any of the built-in tags.")
        (p
          "Finally, sequences or vectors can be used to splice children
          into the parent similar to how the " (code "unquote-splicing")
          " form works in Clojure. For instance this,")
        (code/highlight :clj
          ;;{{
          (ul :class "my-list"
            (map #(li :class "my-item" %) ["item1" "item2"]))
          ;;}}
          )
        (p "is equivalent to this:")
        (code/highlight :clj
          ;;{{
          (apply (ul :class "my-list")
            (map #(li :class "my-item" %) ["item1" "item2"]))
          ;;}}
          ))

      (hdoc :title "Hoplon: Reader Support For Multiline Strings"
        (code/markdown
          ;;{{
          As described above, text nodes are expressed as strings in
          ClojureScript syntax markup, and as text contents of HTML nodes in
          HTML syntax. This is sometimes inconvenient, especially with
          preformatted text, because of issues with indentation and escaping
          reserved characters.

          The Hoplon compiler adds a multiline string delimited mode to the
          reader as a preprocessor pass. Lines in the source file containing
          only whitespace and `;;{{` or `;;}}` denote the start and end,
          respectively, of multiline text blocks. These text blocks will be
          transformed to strings which will be passed on to the reader with
          proper escaping and with leading whitespace indentation removed.
          The indentation level is set by the indentation of the initial
          `;;{{` delimiter.
          ;;}}
          ))

      (hdoc :title "Hoplon: Making the DOM Dynamic"
        (p
          "DOM interactions can be divided into two categories: input and
          output. Input is how the user initiates changes to the state of
          the application, consisting of DOM events like "
          (em "click") ", " (em "change") ", etc. Output is how the state of
          the application is conveyed to the user, consisting of setting
          element attributes, properties, and the contents of text nodes.")
        (p
          "In a Hoplon page input is accepted via the special "
          (code ":on-" (em "event")) " or " (code ":" (em "event")) "
          attributes set on DOM elements. All
          jQuery events are supported, including custom events. The value
          of this attribute is the event handler. For example:")
        (code/highlight :clj
          ;;{{
          (button
            :on-click (fn [event] (handle! event))
            "click this button")
          ;;}}
          )
        (p
          "Output is displayed via the special " (code ":do-" (em "action"))
          " or " (code ":" (em "action"))
          " attributes set on DOM elements. The value of these attributes is
          a formula cell whose value forms the argument to the action. For
          example:")
        (code/highlight :clj
          ;;{{
          (div :do-class (cell= {:active (= 20 page)})
            (h2 "Page 20")
            (p "This is the content for page 20."))
          ;;}}
          )
        (p
          "The " (code ":do-class") " example above adds or removes the "
          (em "“active”") " class, depending on whether the " (code "page")
          " cell’s value is equal to 20 or not, respectively. This
          relationship is maintained automatically, reactively keeping the
          element’s class in sync with the formula.")
        (p
          "The " (code "text") " macro creates DOM text nodes whose content
          automatically updates itself, interpolating cell values and/or
          formulas in the argument string. For example if you have a cell "
          (code "x") ":")
        (code/highlight :clj
          ;;{{
          (p (text "the value of x is ~{x}"))
          ;;}}
          )
        (p
          "This creates a paragraph whose text content is linked to the
          interpolated string.")
        (p
          "Output and input wiring can also be done programmatically using
          the " (code "do!") " and " (code "on!") " multimethods. For
          instance, to set the " (em "“active”") " class on element "
          (code "elem") ", one would do:")
        (code/highlight :clj
          ;;{{
          (do! elem :class {:active true})
          ;;}}
          )
        (p
          "And to add a handler for the " (em "click") " event one would do:")
        (code/highlight :clj
          ;;{{
          (on! elem :click #(handle! %))
          ;;}}
          )
        (p
          "It's important to note the these are not reactive. They're just
          regular functions operating on regular data, not cells. To achieve
          the reactive behavior of the " (code ":do-class") " example above
          the expression can be used as the formula of an anonymous cell
          (anonymous because output is only for side-effects–mutating the
          DOM in this case):")
        (code/highlight :clj
          ;;{{
          (cell= (do! elem :class {:active (= 20 page)}))
          ;;}}
          )
        (p
          "Event handlers are normally set just once, so formula cells don’t
          usually make sense in combination with the " (code "on!")
          " method. This illustrates the I/O model in Hoplon: output
          reactively updates the DOM in relation to the underlying state via
          formula cells, while input updates the underlying state via events
          emitted by the DOM."))

      (hdoc :title "Hoplon: External JS Libs And Extern Files"
        (p
          "External JavaScript libraries can be prepended to the "
          (code "main.js") " file emitted by the ClojureScript compiler and
          extern files for them can be included in the compilation of the
          application code by placing the files in a source directory (one
          listed in " (code ":src-paths") " on " (code "build.boot") " — "
          (code "src") " by default) and using a special naming
          convention.")
          (ul
            (li "External JS files use the " (code ".inc.js") " extension")
            (li "Extern files for GClosure use the " (code ".ext.js")
              " extension"))
        (p
          "External JS files will be prepended to the " (code "main.js") " file
          in alphabetical order."))

      (hdoc :title "Javelin"
        (p
          "You can find documentation about Javelin — cells and formula cells —
          on the "
          (a :href "https://github.com/tailrecursion/javelin#overview"
            "Javelin project page") "."))

      (hdoc :title "Castra"
        (p
          "Castra is the RPC library that comes with Hoplon. It allows the
          illusion of client calling functions defined on the server."))

      (hdoc :title "Castra: Creating a project"
        (p
          "To create a new Hoplon project with Castra you can use "
          (code "lein") ":")
        (code/highlight :bash
          ;;{{
          $ lein new hoplon-castra my-project
          ;;}}
          )
        (p "We will take a look on some of the files from the generated
          project on the next sections."))

      (hdoc :title "Castra: Server side rpc"
        (p
          "Let's take a look on " (code "src/clj/my_project/api.clj") " of
          the generated project.")
        (code/highlight :clj
          ;;{{
          (ns my-project.api
            (:require [tailrecursion.castra :refer [defrpc]]))

          (defrpc get-state []
            {:random (rand-int 100)})
          ;;}}
          )
        (p
          (code "defrpc") " accepts a map like the pre- and postconditions
          map that regular Clojure functions can use. You may use two
          special keys in this map: " (code ":rpc/pre") " and "
          (code ":rpc/query") ".")
        (p
          "The " (code ":rpc/pre") " value is a vector of expressions. The
          expressions inside the vector are evaluated and if any of them
          returns false or nil an assertion error is thrown. You can then
          deal with the error on the client. The " (code ":rpc/pre") " code
          is only evaluated at the entry point. That means that if the client
          calls a rpc A the " (code ":rpc/pre") " of A is
          evaluated. But if in A there is a call to rpc B which also
          has " (code ":rpc/pre") " it will not be executed when it is called
          from A.")
        (p
          "The " (code ":rpc/query") " value is also a vector of expressions,
          but it should only have one expression. The vector content will be
          the response. So when " (code ":rpc/query") " is present, the body
          is only evaluated for side-effects.")
        (p
          "Let's rewrite the " (code "get-state") " rpc using "
          (code ":rpc/pre") " and " (code ":rpc/query") ". Pretend that "
          (code "login!") " is a function that returns true if the user
          is logged in and false otherwise.")
        (code/highlight :clj
          ;;{{
          (defrpc get-state []
            {:rpc/pre [(login!)]
             :rpc/query [{:random (rand-int 100)}]}
            "The function body only matters for side-effects when
            you use the special :rpc/query key.")
          ;;}}
          )
        (p
          "If you are using this special map, the rpc needs a body. It
          can even be " (code "nil") " but it needs something in it, or it
          will consider the map as a regular body and use it as the response
          value."))
      (hdoc :title "Castra: Server configuration"
        (p
          "Now you have functions, but your client cannot reach them just yet.
          Some server configuration is necessary. Castra provides a Ring
          handler that listens to Castra POST requests. These requests
          contain the function that should be called on the server. The handler
          is called " (code "castra") " and is located on the "
          (code "tailrecursion.castra.handler") " namespace. One form to use
          the handler can be found in the " (code "core.clj") " file on the
          generated project:")
        (code/highlight :clj
          ;;{{
          (ns my-project.core
            (:require
              [ring.adapter.jetty               :refer [run-jetty]]
              [ring.middleware.resource         :refer [wrap-resource]]
              [ring.middleware.session          :refer [wrap-session]]
              [ring.middleware.session.cookie   :refer [cookie-store]]
              [ring.middleware.file             :refer [wrap-file]]
              [ring.middleware.file-info        :refer [wrap-file-info]]
              [tailrecursion.castra.handler     :refer [castra]]))

          (defn app [port public-path]
            (-> (castra 'my-project.api)
                (wrap-session {:store (cookie-store {:key "a 16-byte secret"})})
                (wrap-file public-path)
                (wrap-file-info)
                (run-jetty {:join? false :port port})))
          ;;}}
          )
        (p
          "You give " (code "castra") " the namespaces where there are
          functions you want to call from the client. While developing, there
          is no need to worry about the server setup. There is a "
          (code "develoment") " task in the generated project that takes care
          of this step. Just remember to add any other namespaces on your "
          (code "build.boot") " when necessary.")
        (p
          "Notice that you expose every function and rpc in the namespace.
          You can control that using " (code ":only") " and " (code ":exclude")
          " to choose which rpcs and functions will be exposed or which ones
          won't be.")
        (code/highlight :clj
          ;;{{
          ;; Only foo, bar and baz can be accessed from the client:
          (castra '[my-project.api :only [foo bar baz]])

          ;; foo, bar and baz cannot be accessed from the client:
          (castra '[my-project.api :exclude [foo bar baz]])
          ;;}}
          ))

      (hdoc :title "Castra: Client side - mkremote"
        (p
          "On the client side we need the " (code "mkremote") " function from "
          (code "tailrecursion.castra") " namespace. Let's have a look on the
          generated " (code "rpc.cljs") " file:")
        (code/highlight :clj
          ;;{{
          (ns my-project.rpc
            (:require-macros
              [tailrecursion.javelin :refer [defc defc=]])
            (:require
              [tailrecursion.javelin]
              [tailrecursion.castra :refer [mkremote]]))

          (defc state {:random nil})
          (defc error nil)
          (defc loading [])

          (defc= random-number (get state :random))

          (def get-state
            (mkremote 'my-project.api/get-state state error loading))

          (defn init []
            (get-state)
            (js/setInterval get-state 1000))
          ;;}}
          )
        (p
          "We need to require " (code "tailrecursion.javelin") " for the "
          (code "state") ", "(code "error") " and " (code "loading") " cells. "
          (code "mkremote") " takes a quoted namespaced function and three
          cells as arguments and it returns a function. The namespaced function
          is the one that will be called on the server. The returned function
          can be called on the client with any arguments that will also be
          passed to the function called on the server.")
        (p
          (code "mkremote") " sends the POST request to the url the user
          is by default. But you can bind the " (code "*url*") " dynamic var
          to make it POST to any url you want:")
        (code/highlight :clj
          ;;{{
          (binding [*url* "/foo/bar/"]
            (mkremote ...))
          ;;}}
          ))

      (hdoc :title "Castra: Client side - state cell"
        (p
          "When the function succeeds the " (code "state") " cell is updated
          with the return value. When there is an error, the " (code "state")
          " cell doesn't change, so it stays with the last \"good\" state.")
        (p
          "You should use the state to create views for you users. It's common
          to use formula cells to separate the state in more manageable
          pieces."))

      (hdoc :title "Castra: Client side - error cell"
        (p
          "When the function call returns an error, the error cell will be
          updated. One possible error is when you can't reach the server.
          Let's take a look at the contents of the " (code "error") " cell
          after the error occurred:")
        (code/highlight :clj
          ;;{{
          {:type :tailrecursion.castra/exception
           :isa #{}
           :message "The server is temporarily unavailable."
           :data nil
           :cause ["Unexpected end of input"]
           :trace ""
           :status 500
           :severity :error}
          ;;}}
          )
        (p
          "You could then use a formula cell to display the error message to
          the user. You should also clear the error cell after you deal with
          it.")
        (p
          "Another error could be a failure in the " (code ":rpc/pre")
          " condition on the server. Here what is the error when you just put "
          (code "false") " there.")
        (code/highlight :clj
          ;;{{
          {:type :tailrecursion.castra/fatal
           :isa #{:tailrecursion.castra/exception}
           :message "Server error."
           :data nil
           :cause ["Assert failed: (if G__11117 (clojure.core/and false) true)"]
           :trace "clojure.lang.ExceptionInfo: Server error.\n
                   at clojure.core$ex_info.invoke (core.clj:4327)\n
                   ... and the rest of the stacktrace from the server
                   (omitted for brevity)."
           :status 500
           :severity :fatal}
          ;;}}
          )
        (p
          "If you are using the " (code ":rpc/pre") " condition for access
          control, this could mean a login failure.")
        (p
          "You can also throw custom errors on the server, there are several
          already defined on " (code "tailrecursion.castra") " like the "
          (code "auth") " error shown below:")
        (code/highlight :clj
          ;;{{
          (ns my-project.api
            (:require
              [tailrecursion.castra :as c]))

          (throw (c/ex c/auth "Username or password incorrect" {:some "data"}))
          ;;}}
          )
        (p
          "This will give the following error on the client:")
        (code/highlight :clj
          ;;{{
          {:type :tailrecursion.castra/auth
           :isa #{:tailrecursion.castra/exception}
           :message "Username or password incorrect"
           :data {:some "data"}
           :cause []
           :trace "... (omitted for brevity)."
           :status 403
           :severity :error}
          ;;}}
          )
        (p
          "The errors have different " (code ":message") " and "
          (code ":severity") " which makes easier to decide what should
          be displayed for the user or not."))

      (hdoc :title "Castra: Client side - loading cell"
        (p
          "While any " (code "mkremote") " calls are in progress, the loading
          cell won't be empty. After every remote function returns the loading
          cell will be empty again. You can use that to show a loading
          indicator.")
        (code/highlight :clj
          ;;{{
          (div :toggle (cell= (seq loading)) "Loading ...")
          ;;}}
        ))

      (hr)
      (copyright-footer))))
