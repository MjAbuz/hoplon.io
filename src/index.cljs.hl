(page "index.html"
  (:require-macros
    [bootstrap.code             :as code])
  (:require
    [clojure.string             :as string]
    [bootstrap.core             :as core]
    [bootstrap.grid             :as grid]
    [bootstrap.meta             :as meta]
    [bootstrap.list             :as list]
    [bootstrap.page             :as page]
    [bootstrap.glyph            :as glyph]
    [bootstrap.panel            :as panel]
    [bootstrap.button           :as button]
    [bootstrap.navbar           :as navbar]
    [tailrecursion.hoplon.util  :as hutil]))

(def route (hutil/route-cell 10 "#/home/"))

(def-values
  [page-setup nav-bar content-home content-getting-started content-about content-contact]
  (page/navbar-fixed-top
    route         
    "Bootstrap Test"
    "Hoplon demo testing Twitter Bootstrap library design."
    [(a :href "#/home/"                       "Home") (div)]
    [(a :href "#/getting-started/" "Getting Started") (core/container)]
    [(a :href "#/about/"                     "About") (core/container)]
    [(a :href "#/contact/"                 "Contact") (core/container)]))

(defc example     1)
(defc bmi-height  180)
(defc bmi-weight  800)

(defelem my-list [attrs children]
  (let [heading (b)
        body    (ul)
        widget  (div :class "my-list" (heading) (body))]
    (on-append! widget
      (fn [{:keys [title] :as attrs} children]
        (when title (do! heading :text title))
        (add-attributes! widget (dissoc attrs :title))
        (apply body (map li children))))
    (apply widget attrs children)))

(defc= bmi
  (let [h   (/ bmi-height 100)
        w  (/ bmi-weight 10)]
    (/ w (* h h))))

(defc= bmi-msg
  (cond (< bmi 18.5) ["underweight" "orange"]
        (< bmi 25.0) ["normal"      "inherit"]
        (< bmi 30.0) ["overweight"  "orange"]
        :else        ["obese"       "red"]))

(html
  :lang "en"
  (head
    (meta :charset "utf-8")
    (meta :name "viewport" :content "width=device-width, initial-scale=1.0") 
    (link :href "css/bootstrap.min.css"     :rel "stylesheet" :media "screen") 
    (link :href "css/starter-template.css"  :rel "stylesheet" :media "screen"))
  (body
    (nav-bar)
    (content-home
      (core/jumbotron
        (core/container
          (h1 "Hoplon")
          (p "A simpler way to program the web.")
          (p (button/start :href "#/getting-started/" "Get started »"))))
      (core/container
        (grid/row
          (grid/col4
            (h2 "Clojure, everywhere.")
            (p "Write everything in Clojure and ClojureScript, clientside and
               serverside. Even the page markup is ClojureScript that is
               evaluated to produce the DOM. Pages can still be written using
               the familiar HTML syntax if desired."))
          (grid/col4
            (h2 "Simplicity on the client.")
            (p "Use a spreadsheet-like dataflow programming environment to
               manage client state. Develop basic content-oriented pages and
               complex thick-client applications without descending into
               “callback hell”."))
          (grid/col4
            (h2 "Simplicity on the server.")
            (p "Decouple business logic from HTTP-related concerns while
               satisfying complex, fine-grained authorization requirements
               with transparent, performant transfer of Clojure data between
               server and client.")))
        (hr)
        (grid/row
          (grid/col6
            (h2 "Overview " (small "Hoplon in a nutshell."))
            (p "Hoplon provides a number of libraries promoting a simpler
               model for web applications. The project can be divided into
               three main components: the HTML evaluator, the clientside state
               machine, and a serverside RPC server. These components can be
               used together as a full stack, or individually to solve a
               specific problem as a part of another stack.")
            (h2 "HTML Evaluator " (small "Page markup is a program."))
            (p "Web applications are not simply documents. Users must be able
               to interact with them and they must interact with backend
               systems. Web application user interfaces share some of the
               properties of documents, though. UIs are built by composing
               elements in a document tree using HTML markup. However, without
               JavaScript this tree cannot actually interact with the user, at
               all.")
            (p "The incidental complexity of web application UI development
               comes at the boundary between the DOM and the JavaScript
               environment. There is a fundamental disconnect between the
               literal representation of the DOM (the HTML markup) and the
               dynamic environment (the JavaScript VM). The page markup is
               evaluated and the resulting DOM is accessible from JavaScript,
               but it's a one-way linkage; the markup has no mechanism by which
               it can refer to objects other than built-in primitives (i.e. "
               (em "div") ", " (em "span")
               ", etc). The browser's HTML evaluator does not include any means
               of abstraction whatsoever, so there is no literal representation
               for composite forms.")
            (p "Hoplon provides a HTML evaluator that closes the loop, unifying
               the page markup and the JavaScript environment. Page markup,
               expressed using either the standard HTML5 syntax or Clojure
               sexps, is evaluated as ClojureScript and the result becomes the
               DOM for the page. HTML tags are simply ClojureScript vars. Of
               course, Hoplon ships with all of the standard HTML5 primitives
               but the evaluation model facilitates the use of custom compound
               elements defined in the environment, too.")
            (h2 "Components " (small "First-class custom DOM elements."))
            (p "While there is no shortage of templating systems to create
               blobs of DOM elements, there is no mechanism to create custom
               elements that are composable in any meaningful way. Consider
               the situation where a template engine binds a DOM template to
               some data and returns the filled-in DOM subtree. What happens
               when you append a child to that DOM element? The child gets
               appended to the outermost element in the filled template, which
               is probably not useful at all.")
            (p "Hoplon provides facilities for creating real, first-class
               components. That is to say, Hoplon components are first-class
               citizens in the DOM world––they are, essentially, user-defined
               custom DOM elements. They have a literal representation in the
               page markup and they implement the semantics of HTML: setting
               attributes and appending children. When a child is appended to
               a Hoplon component or an attribute is set, either in HTML markup
               or programmatically, the component's implementation is used
               instead of the built-in DOM one. In this way components can be
               built by composing simpler components and those may be used as
               a basis for even more complex components, without running into
               the limitations of template composition.")
            (h2 "Spreadsheets " (small "Client state made simple."))
            (p "Remember how awesome spreadsheets are? You never think about
               state when you’re programming a spreadsheet. Instead, you focus
               on values and the formulas that define the relationships between
               them. When a new value is entered into a cell the rest of the 
               spreadsheet updates itself as necessary to maintain the
               correctness of the formulas.")
            (p "After a spreadsheet is set up you can link its cells to charts
               and forms to create a user interface that manages its own state,
               automatically. User input flows from forms to input cells.
               Formulas then recompute their values as necessary. These values
               then flow to charts and graphs for the user to view.")
            (p "Hoplon applies this crazy, futuristic technology to frontend
               web development. Forgoing the clunky grid metaphor and names
               like " (em "A1") " and " (em "B27") ", Hoplon provides a cell
               reference type. These cells, like cells in a spreadsheet, are
               either updated directly (input cells), or automatically in
               accordance with a formula.")
            (h2 "Charts and Forms " (small "Stateless, automatic UI."))
            (p "The purpose of a program's user interface is to transmit input
               from the user to the underlying state model and to present output
               derived from the underlying state model to the user for viewing.")
            (p "In a web application the user interface is derived from the page
               markup. User input consists entirely of DOM events: "
               (em "click") ", " (em "change") ", etc. Output is presented to
               the user by manipulating the properties of DOM elements: adding
               or removing CSS classes, changing the content of text nodes, 
               etc.")
            (p "Hoplon provides bindings that can be used to link DOM elements
               to the underlying state model in the same way that charts and
               forms are linked to cells in a spreadsheet. Once the structure
               of the DOM and the linkages between the DOM and cells are
               defined, the user interface manages itself.")
            )
          (grid/col6
            (h2 (small "Examples"))
            (list/divgroup
              (list/divitem
                :on-click #(reset! example 1)
                (a
                  :do-toggle (cell= (not= example 1))
                  (h3 :class "panel-title" "Typical Page"))
                (div
                  :do-toggle (cell= (= example 1))
                  (h3 :class "panel-title" "Typical Page")
                  (hr)
                  (p "The page can be coded in either ClojureScript or HTML
                     syntax. The compiler can parse either one. It's easy to
                     add a preprocessing step to parse HAML, etc. if desired.
                     HTML is usually more verbose and noisy than ClojureScript,
                     so most examples in this document will be using the latter
                     syntax.")
                  (hr)
                  (p :class "text-muted" "Using ClojureScript syntax:")
                  (code/clj
                    ;;{{
                    (page "foo/bar.html"
                      (:require [my.lib :as lib]))

                    (defc clicks 0)

                    (html
                      (head
                        (title "Hello World")
                        (link :rel "stylesheet" :href "css/main.css"))
                      (body
                        (lib/heading-large "Hello, world!")
                        (p (text "You've clicked ~{clicks} times."))
                        (button :on-click #(swap! clicks inc) "Click me!")))
                    ;;}}
                    )
                  (p :class "text-muted" "Using HTML syntax:")
                  (code/xml
                    ;;{{
                    <script type="text/hoplon">
                      (page "foo/bar.html"
                        (:require [my.lib :as lib]))

                      (defc clicks 0)
                    </script>

                    <html>
                      <head>
                        <title>Hello World</title>
                        <link rel="stylesheet" href="css/main.css">
                      </head>
                      <body>
                        <lib.heading-large>Hello, world!</lib.heading-large>
                        <p><text>You've clicked ~{clicks} times.</text></p>
                        <button on-click="{{ #(swap! clicks inc) }}">
                          Click me!
                        </button>
                      </body>
                    </html>
                    ;;}}
                    )
                  )
                )
              (list/divitem
                :on-click #(reset! example 2)
                (a :class "topfix" :do-scroll-to (cell= (= example 2)))
                (a
                  :do-toggle (cell= (not= example 2))
                  (h3 :class "panel-title" "BMI Calculator"))
                (div
                  :do-toggle (cell= (= example 2))
                  (h3 :class "panel-title" "BMI Calculator")
                  (hr)
                  (p "This is an example of a spreadsheet-like application.
                     The application's state is contained in "
                     (em "cells")
                     " which are wired up to the DOM. DOM events cause changes
                     to the underlying cells and formula cells in turn cause
                     changes to the DOM.")
                  (hr)
                  (p :class "text-muted" "The demo:")
                  (panel/default
                    (panel/body
                      (div
                        (form
                          (div
                            :class "form-group"
                            (label (text "Height (~{bmi-height} cm)"))
                            (input 
                              :on-change #(reset! bmi-height (val-id "bmi-ht"))
                              :id     "bmi-ht"
                              :class  "form-control"
                              :type   "range"
                              :min    0
                              :max    250
                              :value  @bmi-height))
                          (div
                            :class "form-group"
                            (label (text "Weight (~(.toFixed (/ bmi-weight 10) 1) kg)"))
                            (input 
                              :on-change #(reset! bmi-weight (val-id "bmi-wt"))
                              :id     "bmi-wt"
                              :class  "form-control"
                              :type   "range"
                              :min    0
                              :max    1500
                              :value  @bmi-weight))
                          (div
                            :class "form-group"
                            (label
                              (text "BMI ~(.toFixed bmi 1) (~(first bmi-msg))"))
                            (input 
                              :do-css (cell= {:background-color (second bmi-msg)})
                              :readonly   true
                              :class      "form-control"
                              :type       "range"
                              :min        0
                              :max        500
                              :do-value   (cell= (* bmi 10))))))))
                  (p :class "text-muted" "The cells:")
                  (code/clj
                    ;;{{
                    (def height (cell 180)) ; height in cm
                    (def weight (cell 80))  ; weight in kg

                    (def bmi ; body mass index, description, color
                      (cell=
                        (let [htm (/ height 100) ; height in meters
                              bmi (/ weight (* htm htm))]
                          (cond (< bmi 18.5) [bmi "underweight"  "orange"]
                                (< bmi 25.0) [bmi "normal"      "inherit"]
                                (< bmi 30.0) [bmi "overweight"   "orange"]
                                :else        [bmi "obese"           "red"]))))
                    ;;}}
                    )
                  (p :class "text-muted" "The user interface:")
                  (code/clj
                    ;;{{
                    ;; Some details related to <input type="range">
                    ;; have been omitted for clarity.
                    (form
                      (label (text "Height (~{height} cm)"))
                      (input
                        :id "bmi-h"
                        :value @height
                        :on-change #(reset! height (val-id "bmi-h")))

                      (label (text "Weight (~{weight} kg)"))
                      (input
                        :id "bmi-w"
                        :value @weight
                        :on-change #(reset! weight (val-id "bmi-w")))

                      (label (text "BMI ~(first bmi) (~(second bmi))"))
                      (input
                        :do-value (cell= (first bmi))
                        :do-css (cell= {:background-color (nth bmi 2)})))
                    ;;}}
                    )))
              (list/divitem
                :on-click #(reset! example 3)
                (a :class "topfix" :do-scroll-to (cell= (= example 3)))
                (a
                  :do-toggle (cell= (not= example 3))
                  (h3 :class "panel-title" "List Component"))
                (div
                  :do-toggle (cell= (= example 3))
                  (h3 :class "panel-title" "List Component")
                  (hr)
                  (p "This is an example of a custom element, or component. The "
                     (em "on-append!")
                     " function is used to provide the implementation for
                     appending children and setting attributes. This ensures 
                     that children are, in this case, properly wrapped in list
                     item elements and appended to the inner unordered list
                     instead of to the outermost element. A special "
                     (em "title")
                     " attribute is also implemented here that sets the text of
                     the inner bold element.")
                  (p "By implementing the HTML semantic this component becomes
                     a first-class DOM element. It can be used in page markup
                     and it can be passed around without any need for the
                     recipient to understand its internal structure. It can be
                     combined with other elements at any level to create more
                     complex components.")
                  (hr)
                  (p :class "text-muted" "The demo:")
                  (panel/default
                    (panel/body
                      (div
                        (p "See the list component below.")
                        (hr)
                        (my-list
                          :title "Items:"
                          (span "item one")
                          (span "item two")
                          (span "item three")))))
                  (p :class "text-muted" "The component constructor:")
                  (code/clj
                    ;;{{
                    ;; Define custom element <my-list>.
                    (defelem my-list [attrs children]
                      (let [head (b)  ; Obtain references to inner
                            body (ul) ; container elements.
                            this (div :class "my-list" (head) (body))]
                        ;; Implement appendChild/setAttribute.
                        (on-append! this 
                          (fn [{:keys [title] :as attrs} children]
                            ;; The "title" attribute sets title text.
                            (when title (do! head :text title))
                            ;; Other attributes are set on outer div.
                            (add-attributes! this (dissoc attrs :title))
                            ;; Children are wrapped in <li>s and
                            ;; appended to inner <ul> element.
                            (apply body (map li children))))
                        ;; Initialize element.
                        (apply this attrs children)))
                    ;;}}
                    )
                  (p :class "text-muted" "The page markup:")
                  (code/clj
                    ;;{{
                    (div
                      (p "See the list component below.")
                      (hr)
                      (my-list
                        :title "Items:"
                        (span "item one")
                        (span "item two")
                        (span "item three")))
                    ;;}}
                    )
                  )))))
        (hr)
        (footer :style "padding:30px 0px;" "Copyright 100")))
    (content-getting-started
      (grid/row
        (grid/col2)
        (grid/col8
          (div :class "page-header" (h1 "Hello World"))
          (p "Hoplon is a set of libraries for making web pages."))
        (grid/col2)) 
      (grid/row
        (grid/col2
          :style "text-align:right"
          (p (b "This is what the code does.")))
        (grid/col8
          (div
            :class "panel panel-default"
            (div :class "panel-heading" "Example:")
            (div :class "panel-body"    "Foo bar.")) 
          (code/xml
            ;;{{
            <script type="text/hoplon">
              (page index.html)
              
              (defn my-list [& items]
                (div
                  :class "my-list"
                  (apply ul (map #(li (div :class "my-list-item" %)) items))))

              (def clicks (cell 0))
            </script>
                
            <html>
              <head>
                <title>example page</title>
              </head>
              <body>
                <h1>Hello, Hoplon</h1>
                
                <my-list>
                  <span>first thing</span>
                  <span>second thing</span>
                </my-list>

                <p><text>You've clicked ~{clicks} times, so far.</text></p>
                <button on-click="{{ #(swap! clicks inc) }}">click me</button>
              </body>
            </html>
            ;;}}
            ) 
          (hr) 
          (footer :style "padding:30px 0px;" "Copyright 100"))
        (grid/col2
          (p "asdf"))))
    (content-about
      (h1 "About")
      (p "This is the about content."))
    (content-contact
      (h1 "Contact")
      (p "This is the contact content."))))
