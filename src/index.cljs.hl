(page "index.html"
  (:require-macros
    [bootstrap.code             :as code])
  (:require
    [clojure.string             :as string]
    [bootstrap.core             :as core]
    [bootstrap.grid             :as grid]
    [bootstrap.meta             :as meta]
    [bootstrap.list             :as list]
    [bootstrap.page             :as page]
    [bootstrap.glyph            :as glyph]
    [bootstrap.panel            :as panel]
    [bootstrap.button           :as button]
    [bootstrap.navbar           :as navbar]
    [tailrecursion.hoplon.util  :as hutil]))

(def route (hutil/route-cell 10 "#/home/"))

(def hoplon-url         "https://github.com/tailrecursion/hoplon")
(def boot-url           "https://github.com/tailrecursion/boot")
(def hoplon-clojars-url "https://clojars.org/tailrecursion/hoplon")

(def-values
  [page-setup nav-bar content-home content-getting-started content-about content-contact]
  (page/navbar-fixed-top
    route         
    "Hoplon"
    "Hoplon"
    [(a :href "#/home/"                       "Home") (div)]
    [(a :href "#/getting-started/" "Getting Started") (core/container)]
    [(a :href hoplon-url :target "_blank"   "GitHub") (core/container)]))

(defc example     1)
(defc bmi-height  180)
(defc bmi-weight  800)

(defelem my-list [attrs children]
  (let [heading (b)
        body    (ul)
        widget  (div :class "my-list" (heading) (body))]
    (on-append! widget
      (fn [{:keys [title] :as attrs} children]
        (when title (do! heading :text title))
        (add-attributes! widget (dissoc attrs :title))
        (apply body (map li children))))
    (apply widget attrs children)))

(defc= bmi
  (let [h   (/ bmi-height 100)
        w  (/ bmi-weight 10)]
    (/ w (* h h))))

(defc= bmi-msg
  (cond (< bmi 18.5) ["underweight" "orange"]
        (< bmi 25.0) ["normal"      "inherit"]
        (< bmi 30.0) ["overweight"  "orange"]
        :else        ["obese"       "red"]))

(def video-dims         {:width 523 :height 392})
(def video-url          "//www.youtube-nocookie.com/embed/XQu8TTBmGhA")
(def video-thumb-url    "http://img.youtube.com/vi/XQu8TTBmGhA/0.jpg")

(defn hyphenate! []
  (.. (js/jQuery "p") (addClass "hyphenate") (css "text-align" "justify"))
  (.run js/Hyphenator))

(add-initfn!
  (fn []
    (hyphenate!)))

(html
  :lang "en"
  (head
    (meta :charset "utf-8")
    (meta :name "viewport" :content "width=device-width, initial-scale=1.0") 
    (link :href "css/bootstrap.min.css"     :rel "stylesheet" :media "screen") 
    (link :href "css/starter-template.css"  :rel "stylesheet" :media "screen"))
  (body
    (nav-bar)
    (noscript (div :class "nojs-error" "This page uses JavaScript but it looks like you have it turned off."))
    (content-home
      (core/jumbotron
        (core/container
          (h1 "Hoplon")
          (p "A simpler way to program the web.")
          (p (button/start :href "#/getting-started/" "Get started »"))))
      (core/container
        (grid/row
          (grid/col4
            (h2 "Clojure, everywhere.")
            (p "Write everything in Clojure and ClojureScript, clientside and
               serverside. Even the page markup is ClojureScript that is
               evaluated to produce the DOM. Pages can still be written using
               the familiar HTML syntax if desired."))
          (grid/col4
            (h2 "Simplicity on the client.")
            (p "Use a spreadsheet-like dataflow programming environment to
               manage client state. Develop basic content-oriented pages and
               complex thick-client applications without descending into
               “callback hell”."))
          (grid/col4
            (h2 "Simplicity on the server.")
            (p "Decouple business logic from HTTP-related concerns while
               satisfying complex, fine-grained authorization requirements
               with transparent, performant transfer of Clojure data between
               server and client.")))
        (hr)
        (grid/row
          (grid/col6
            (h2 "Overview " (small "Hoplon in a nutshell."))
            (p "Hoplon provides a number of libraries promoting a simpler
               model for web applications. The project can be divided into
               three main components: the HTML evaluator, the clientside state
               machine, and serverside RPC middleware. These components can be
               used together as a full stack, or individually as a part of
               another stack.")
            (p "More concretely, Hoplon ships with a compiler for compiling
               Hoplon pages into HTML and JavaScript (implemented as a build 
               task for the "
               (a :href boot-url :target "_blank" "boot")
               " build tool), ClojureScript libraries for creating
               spreadsheet-like dataflow programs and wiring them to the DOM,
               and ClojureScript and Clojure libraries for RPC interaction
               between client and server.")
            (p "The source code for Hoplon is hosted on "
               (a :href hoplon-url :target "_blank" "GitHub")
               " and Maven artifacts are deployed to "
               (a :href hoplon-clojars-url :target "_blank" "Clojars")
               ". Contributions of code, feedback, feature requests, etc. are
               welcome. Please read the "
               (a :style "text-decoration:line-through;" :href "javascript:void(0)" "Contributors")
               " page for more information.")
            (h2 "Web Apps " (small "Applications, not documents."))
            (p "Web applications are not documents. Users need to be able to
               interact with them. They contain state. Through them the user
               communicates with backend systems to have some effect on the
               real world. Of course they're composed of HTML, CSS, etc., but
               any resemblance to trees of HTML documents is incidental;
               conflating the two leads to an explosion of needless complexity.")
            (p "Hoplon web apps are organized like applications. The Hoplon
               compiler produces artifacts, not documents. These artifacts are
               equivalent to JAR files in Maven–their coordinates being the
               URL on which they're deployed. The compilation unit is the page,
               which produces a single compiled HTML file. This HTML file loads
               a compiled JavaScript file, "
               (em "main.js")
               ", a dependency shared by all pages in the project.")
            (h2 "HTML Evaluator " (small "Page markup is a program."))
            (p "Web application user interfaces are specified as trees of
               nested elements in HTML markup, but this document-like
               appearance is misleading. Without JavaScript this markup cannot
               provide the dynamic behavior that web applications require.")
            (p "It is at the boundary between the DOM and the JavaScript
               environment that the incindental complexities of web application
               UI development are found. There is a fundamental disconnect
               between the literal representation of the DOM (the HTML markup)
               and the dynamic environment (the JavaScript VM). The page markup
               is evaluated by the browser and the resulting DOM is then
               accessible from JavaScript, but it's a one-way linkage–there is
               no way to refer to objects created dynamically in the JavaScript
               environment from the markup. The browser's HTML evaluation model
               lacks a means of abstraction, preventing the development of new
               elements by composition.")
            (p "Hoplon provides a HTML evaluator that closes the loop, unifying
               the page markup and the JavaScript environment. Page markup,
               expressed in either the standard HTML5 syntax or Clojure sexps,
               is evaluated as ClojureScript and the result becomes the DOM for
               the page. HTML tags are simply ClojureScript vars. Of course,
               Hoplon ships with all of the standard HTML5 primitives but the
               evaluation model now facilitates the use of custom compound
               elements defined in the environment, too.")
            (p "Additionally, the unification of HTML and ClojureScript syntax,
               semantics, and namespace in the HTML evaluator facilitates the
               use of macros in markup.  This makes it possible to write
               powerful looping and control structures for use in the page's
               HTML markup itself, bringing the power and expressiveness of
               Lisp to HTML.")
            (h2 "Components " (small "First-class custom DOM elements."))
            (p "While there is no shortage of templating systems to create
               blobs of DOM elements, there is no mechanism to create custom
               elements that are composable in any meaningful way. Consider
               the situation where a template engine binds a DOM template to
               some data and returns the filled-in DOM subtree. What happens
               when you append a child to, or set an attribute on that DOM
               element? The child gets appended to, or attribute set on the
               outermost element of the filled template, generally not what is
               required for the composition semantic.")
            (p "Hoplon provides facilities for creating real, first-class
               components. That is to say, Hoplon components are first-class
               citizens in the DOM world–they are, essentially, user-defined
               custom DOM elements. They have a literal representation in the
               page markup and they implement the semantics of HTML: setting
               attributes and appending children. When a child is appended to
               a Hoplon component or an attribute is set, either in HTML markup
               or programmatically, the component's implementation is used
               instead of the built-in DOM one. In this way components can be
               built by composing simpler components and those may be used as
               a basis for even more complex components, without running into
               the limitations of template composition.")
            (h2 "Spreadsheets " (small "Client state made simple."))
            (p "Remember how awesome spreadsheets are? You never think about
               state when you’re programming a spreadsheet. Instead, you focus
               on values and the formulas that define the relationships between
               them. When a new value is entered into a cell the rest of the 
               spreadsheet updates itself as necessary to maintain the
               correctness of the formulas.")
            (p "After a spreadsheet is set up you can link its cells to charts
               and forms to create a user interface that manages its own state,
               automatically. User input flows from forms to input cells.
               Formulas then recompute their values as necessary. These values
               then flow to charts and graphs for the user to view.")
            (p "Hoplon applies this crazy, futuristic technology to frontend
               web development. Forgoing the clunky grid metaphor and names
               like " (em "A1") " and " (em "B27") ", Hoplon provides a cell
               reference type. These cells, like cells in a spreadsheet, are
               either updated directly (input cells), or automatically in
               accordance with a formula.")
            (h2 "Charts and Forms " (small "Stateless, automatic UI."))
            (p "The purpose of a program's user interface is to transmit input
               from the user to the underlying state model and to present output
               derived from the underlying state model to the user for viewing.")
            (p "In a web application the user interface is derived from the page
               markup. User input consists entirely of DOM events: "
               (em "click") ", " (em "change") ", etc. Output is presented to
               the user by manipulating the properties of DOM elements: adding
               or removing CSS classes, changing the content of text nodes, 
               etc.")
            (p "Hoplon provides bindings that can be used to link DOM elements
               to the underlying state model in the same way that charts and
               forms are linked to cells in a spreadsheet. Once the structure
               of the DOM and the linkages between the DOM and cells are
               defined, the user interface manages itself.")
            )
          (grid/col6
            (h2 (small "Screencast"))
            (panel/default
              (panel/body
                (iframe
                  :class            "center-block"
                  :width            (:width video-dims)
                  :height           (:height video-dims)
                  :src              video-url
                  :frameborder      "0"
                  :allowfullscreen  true)))
            (h2 (small "Examples"))
            (list/divgroup
              (list/divitem
                :on-click #(reset! example 1)
                (a
                  :do-toggle (cell= (not= example 1))
                  (h3 :class "panel-title" "Typical Page"))
                (div
                  :do-toggle (cell= (= example 1))
                  (h3 :class "panel-title" "Typical Page")
                  (hr)
                  (p "The page can be coded in either ClojureScript or HTML
                     syntax. The compiler can parse either one. It's easy to
                     add a preprocessing step to parse HAML, etc. if desired.
                     HTML is usually more verbose and noisy than ClojureScript,
                     so most examples in this document will be using the latter
                     syntax.")
                  (hr)
                  (p :class "text-muted" "Using ClojureScript syntax:")
                  (code/clj
                    ;;{{
                    (page "foo/bar.html"
                      (:require [my.lib :as lib]))

                    (defc clicks 0)

                    (html
                      (head
                        (title "Hello World")
                        (link :rel "stylesheet" :href "css/main.css"))
                      (body
                        (lib/heading-large "Hello, world!")
                        (p (text "You've clicked ~{clicks} times."))
                        (button :on-click #(swap! clicks inc) "Click me!")))
                    ;;}}
                    )
                  (p :class "text-muted" "Using HTML syntax:")
                  (code/xml
                    ;;{{
                    <script type="text/hoplon">
                      (page "foo/bar.html"
                        (:require [my.lib :as lib]))

                      (defc clicks 0)
                    </script>

                    <html>
                      <head>
                        <title>Hello World</title>
                        <link rel="stylesheet" href="css/main.css">
                      </head>
                      <body>
                        <lib.heading-large>Hello, world!</lib.heading-large>
                        <p><text>You've clicked ~{clicks} times.</text></p>
                        <button on-click="{{ #(swap! clicks inc) }}">
                          Click me!
                        </button>
                      </body>
                    </html>
                    ;;}}
                    )
                  )
                )
              (list/divitem
                :on-click #(reset! example 2)
                (a :class "topfix" :do-scroll-to (cell= (= example 2)))
                (a
                  :do-toggle (cell= (not= example 2))
                  (h3 :class "panel-title" "BMI Calculator"))
                (div
                  :do-toggle (cell= (= example 2))
                  (h3 :class "panel-title" "BMI Calculator")
                  (hr)
                  (p "This is an example of a spreadsheet-like application.
                     The application's state is contained in "
                     (em "cells")
                     " which are wired up to the DOM. DOM events cause changes
                     to the underlying cells and formula cells in turn cause
                     changes to the DOM.")
                  (hr)
                  (p :class "text-muted" "The demo:")
                  (panel/default
                    (panel/body
                      (div
                        (form
                          (div
                            :class "form-group"
                            (label (text "Height (~{bmi-height} cm)"))
                            (input 
                              :on-change #(reset! bmi-height (val-id "bmi-ht"))
                              :id     "bmi-ht"
                              :class  "form-control"
                              :type   "range"
                              :min    0
                              :max    250
                              :value  @bmi-height))
                          (div
                            :class "form-group"
                            (label (text "Weight (~(.toFixed (/ bmi-weight 10) 1) kg)"))
                            (input 
                              :on-change #(reset! bmi-weight (val-id "bmi-wt"))
                              :id     "bmi-wt"
                              :class  "form-control"
                              :type   "range"
                              :min    0
                              :max    1500
                              :value  @bmi-weight))
                          (div
                            :class "form-group"
                            (label
                              (text "BMI ~(.toFixed bmi 1) (~(first bmi-msg))"))
                            (input 
                              :do-css (cell= {:background-color (second bmi-msg)})
                              :readonly   true
                              :class      "form-control"
                              :type       "range"
                              :min        0
                              :max        500
                              :do-value   (cell= (* bmi 10))))))))
                  (p :class "text-muted" "The cells:")
                  (code/clj
                    ;;{{
                    (def height (cell 180)) ; height in cm
                    (def weight (cell 80))  ; weight in kg

                    (def bmi ; body mass index, description, color
                      (cell=
                        (let [htm (/ height 100) ; height in meters
                              bmi (/ weight (* htm htm))]
                          (cond (< bmi 18.5) [bmi "underweight"  "orange"]
                                (< bmi 25.0) [bmi "normal"      "inherit"]
                                (< bmi 30.0) [bmi "overweight"   "orange"]
                                :else        [bmi "obese"           "red"]))))
                    ;;}}
                    )
                  (p :class "text-muted" "The user interface:")
                  (code/clj
                    ;;{{
                    ;; Some details related to <input type="range">
                    ;; have been omitted for clarity.
                    (form
                      (label (text "Height (~{height} cm)"))
                      (input
                        :id "bmi-h"
                        :value @height
                        :on-change #(reset! height (val-id "bmi-h")))

                      (label (text "Weight (~{weight} kg)"))
                      (input
                        :id "bmi-w"
                        :value @weight
                        :on-change #(reset! weight (val-id "bmi-w")))

                      (label (text "BMI ~(first bmi) (~(second bmi))"))
                      (input
                        :do-value (cell= (first bmi))
                        :do-css (cell= {:background-color (nth bmi 2)})))
                    ;;}}
                    )))
              (list/divitem
                :on-click #(reset! example 3)
                (a :class "topfix" :do-scroll-to (cell= (= example 3)))
                (a
                  :do-toggle (cell= (not= example 3))
                  (h3 :class "panel-title" "List Component"))
                (div
                  :do-toggle (cell= (= example 3))
                  (h3 :class "panel-title" "List Component")
                  (hr)
                  (p "This is an example of a custom element, or component. The "
                     (em "on-append!")
                     " function is used to provide the implementation for
                     appending children and setting attributes. This ensures 
                     that children are, in this case, properly wrapped in list
                     item elements and appended to the inner unordered list
                     instead of to the outermost element. A special "
                     (em "title")
                     " attribute is also implemented here that sets the text of
                     the inner bold element.")
                  (p "By implementing the HTML semantic this component becomes
                     a first-class DOM element. It can be used in page markup
                     and it can be passed around without any need for the
                     recipient to understand its internal structure. It can be
                     combined with other elements at any level to create more
                     complex components.")
                  (hr)
                  (p :class "text-muted" "The demo:")
                  (panel/default
                    (panel/body
                      (div
                        (p "See the list component below.")
                        (hr)
                        (my-list
                          :title "Items:"
                          (span "item one")
                          (span "item two")
                          (span "item three")))))
                  (p :class "text-muted" "The component constructor:")
                  (code/clj
                    ;;{{
                    ;; Define custom element <my-list>.
                    (defelem my-list [attrs children]
                      (let [head (b)  ; Obtain references to inner
                            body (ul) ; container elements.
                            this (div :class "my-list" (head) (body))]
                        ;; Implement appendChild/setAttribute.
                        (on-append! this 
                          (fn [{:keys [title] :as attrs} children]
                            ;; The "title" attribute sets title text.
                            (when title (do! head :text title))
                            ;; Other attributes are set on outer div.
                            (add-attributes! this (dissoc attrs :title))
                            ;; Children are wrapped in <li>s and
                            ;; appended to inner <ul> element.
                            (apply body (map li children))))
                        ;; Initialize element.
                        (apply this attrs children)))
                    ;;}}
                    )
                  (p :class "text-muted" "The page markup:")
                  (code/clj
                    ;;{{
                    (div
                      (p "See the list component below.")
                      (hr)
                      (my-list
                        :title "Items:"
                        (span "item one")
                        (span "item two")
                        (span "item three")))
                    ;;}}
                    )
                  )))))
        (hr)
        (footer
          :style "padding:30px 0px;"
          (div
            :style "text-align:center;"
            "Copyright © Alan Dipert and Micha Niskin. All rights reserved."))))
    (content-getting-started
      (grid/row
        (grid/col2)
        (grid/col8
          (div :class "page-header" (h1 "Hello World"))
          (p "Hoplon is a set of libraries for making web pages."))
        (grid/col2)) 
      (grid/row
        (grid/col2
          :style "text-align:right"
          (p (b "This is what the code does.")))
        (grid/col8
          (div
            :class "panel panel-default"
            (div :class "panel-heading" "Example:")
            (div :class "panel-body"    "Foo bar.")) 
          (code/xml
            ;;{{
            <script type="text/hoplon">
              (page index.html)
              
              (defn my-list [& items]
                (div
                  :class "my-list"
                  (apply ul (map #(li (div :class "my-list-item" %)) items))))

              (def clicks (cell 0))
            </script>
                
            <html>
              <head>
                <title>example page</title>
              </head>
              <body>
                <h1>Hello, Hoplon</h1>
                
                <my-list>
                  <span>first thing</span>
                  <span>second thing</span>
                </my-list>

                <p><text>You've clicked ~{clicks} times, so far.</text></p>
                <button on-click="{{ #(swap! clicks inc) }}">click me</button>
              </body>
            </html>
            ;;}}
            ) 
          (hr) 
          (footer :style "padding:30px 0px;" "Copyright 100"))
        (grid/col2
          (p "asdf"))))))
